package trigram

import (
	"fmt"
	"math/rand"
	"regexp"
	"strings"
	"time"
)

// Storer is an interface to enable storing and retrieving data.
type Storer interface {
	Append(key, value string)
	Get(key string) []string
	RandomKey() string
}

// Learn generates new trigram maps for a given text.
func Learn(db Storer, text string) error {
	words := strings.Split(strings.ToLower(text), " ")

	for i := 0; i < len(words)-2; i++ {
		// the trigram key is generated by getting the current and next word - we strip it from special characters
		trigramKey := strings.Join(words[i:i+2], " ")
		trigramKey, err := cleanText(trigramKey)
		if err != nil {
			return err
		}

		// suffixKey is the 3rd word of the trigram
		suffixKey := words[i+2]

		db.Append(trigramKey, suffixKey)
	}
	return nil
}

// Generate generates random texts based on what was learned.
func Generate(db Storer, text string, nextKey string) (string, error) {
	if nextKey == "" {
		nextKey = db.RandomKey()
		splitKey := strings.Split(nextKey, " ")
		text = fmt.Sprintf("%s %s", strings.Title(splitKey[0]), splitKey[1])
	}

	cleanKey, err := cleanText(nextKey)
	if err != nil {
		return "", err
	}

	nextSuffixes := db.Get(cleanKey)
	if nextSuffixes == nil {
		return text, nil
	}

	rand.Seed(time.Now().UnixNano())
	suffix := nextSuffixes[rand.Intn(len(nextSuffixes))]

	text = fmt.Sprintf("%s %s", text, capitalizeIfNeeded(nextKey, suffix))
	nextWords := fmt.Sprintf("%s %s", strings.Split(nextKey, " ")[1], suffix)

	return Generate(db, text, nextWords)
}

// cleanText will remove special characters from a given text.
// Trigram keys should not include special characters for simplicity of search.
func cleanText(text string) (string, error) {
	// Make a Regex to say we only want letters and numbers
	reg, err := regexp.Compile("[^A-Za-zÀ-ÿ0-9? ]+")
	if err != nil {
		return "", err
	}
	return reg.ReplaceAllString(text, ""), nil
}

// this will capitalize the next word if there's a sentence terminator in the previous one.
func capitalizeIfNeeded(previous, next string) string {
	lastChar := string(previous[len(previous)-1])

	if lastChar == "!" || lastChar == "." || lastChar == "?" || lastChar == "\n" {
		return strings.Title(next)
	}
	return next
}
