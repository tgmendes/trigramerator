package trigram_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/tgmendes/trigramerator/domain/trigram"
	"github.com/tgmendes/trigramerator/pkg/db"
)

func TestLearnTrigram(t *testing.T) {
	db := db.NewMapSliceDB()
	in := "To be or\n not, to be! That"

	err := trigram.Learn(db, in)

	assert.NoError(t, err)
	// "to be" occurs twice in the text, so we expect it 2 times
	assert.Len(t, db.Get("to be"), 2)
	assert.Len(t, db.Get("be or"), 1)
	assert.Len(t, db.Get("or not"), 1)
	assert.Len(t, db.Get("not to"), 1)
	// "be that" has no matched key, so we expect it to not be present
	assert.Nil(t, db.Get("be that"))
}

func TestGenerate(t *testing.T) {
	// since we want to test a predictable piece of text generated by the generator,
	// we can no rely on the randomness of the database (particularly choosing the first random key).
	// For this reason we rely on a mock which we have full control over.
	testData := map[string][]string{
		"to be":        {"or"},
		"be or":        {"not"},
		"or not":       {"to,"},
		"not to":       {"that"},
		"to that":      {"is"},
		"that is":      {"the"},
		"is the":       {"question."},
		"the question": {"is"},
		"question is":  {"that"},
	}
	mockDB := new(storerMock)
	mockDB.On("Get", mock.Anything).Return(nil)
	// this guarantees repeatibility by always returning the same "seed" text
	mockDB.On("RandomKey").Return("to be")
	mockDB.data = testData

	text, err := trigram.Generate(mockDB)

	assert.Equal(t, "To be or not to, that is the question. Is that.\n", text)
	assert.NoError(t, err)
}

type storerMock struct {
	mock.Mock

	data map[string][]string
}

func (m *storerMock) Append(key, value string) {
	m.Called(key, value)
}

func (m *storerMock) Get(key string) []string {
	m.Called(key)
	return m.data[key]
}

func (m *storerMock) RandomKey() string {
	args := m.Called()
	return args.String(0)
}
