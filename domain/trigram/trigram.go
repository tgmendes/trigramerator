package trigram

import (
	"fmt"
	"math/rand"
	"regexp"
	"strings"
	"time"
)

const (
	// maxTextLength is the maximum amount of characters of the generated text.
	maxTextLength int = 1000
)

// Storer is an interface to enable storing and retrieving data.
type Storer interface {
	Append(key, value string)
	Get(key string) []string
	RandomKey() string
}

// Learn generates new trigrams for a given text.
// It uses a map to slice database to store the trigrams.
func Learn(db Storer, text string) error {
	text = strings.ToLower(text)
	text = strings.ReplaceAll(text, "\n", " ")
	words := strings.Fields(text)

	for i := 0; i < len(words)-2; i++ {
		// the trigram key is generated by getting the current and next word - we strip it from special characters
		key := strings.Join(words[i:i+2], " ")
		key, err := cleanText(key)
		if err != nil {
			return err
		}

		suffix := words[i+2]

		db.Append(key, suffix)
	}
	return nil
}

// Generate generates random texts based the learned trigrams in the database.
// It is a recursive function - if no initial key is provided, the text will
// be generated from a random key in the database.
func Generate(db Storer, text string, key string) (string, error) {
	if key == "" {
		key = db.RandomKey()
		// we want to capitalize the first letter of the first word on the final text.
		keyParts := strings.Split(key, " ")
		text = fmt.Sprintf("%s %s", strings.Title(keyParts[0]), keyParts[1])
	}

	cleanKey, err := cleanText(key)
	if err != nil {
		return "", err
	}

	// we break out of the generator if there are no more available suffixes or if we've
	// reached a new paragraph.
	nextSuffixes := db.Get(cleanKey)
	if nextSuffixes == nil || len(text) > maxTextLength {
		if !isEndOfSentence(text) {
			text = fmt.Sprintf("%s.\n", text)
		}
		return text, nil
	}

	suffix := getRandomSuffix(nextSuffixes)

	text = fmt.Sprintf("%s %s", text, capitalizeIfNeeded(key, suffix))

	// to avoid splitting the whole text, to get the last 2 words, we provide the build key
	nextKey := fmt.Sprintf("%s %s", strings.Split(key, " ")[1], suffix)

	return Generate(db, text, nextKey)
}

// cleanText will remove special characters from a given text.
// Trigram keys should not include special characters for simplicity of search.
func cleanText(text string) (string, error) {
	// Make a Regex to say we only want letters and numbers
	reg, err := regexp.Compile("[^A-Za-zÀ-ÿ0-9? ]+")
	if err != nil {
		return "", err
	}
	return reg.ReplaceAllString(text, ""), nil
}

// this will capitalize the next word if there's a sentence terminator in the previous one.
func capitalizeIfNeeded(previous, next string) string {
	if isEndOfSentence(previous) {
		return strings.Title(next)
	}
	return next
}

func isEndOfSentence(sentence string) bool {
	lastChar := string(sentence[len(sentence)-1])

	return lastChar == "!" || lastChar == "." || lastChar == "?"
}

func getRandomSuffix(suffixes []string) string {
	rand.Seed(time.Now().UnixNano())
	return suffixes[rand.Intn(len(suffixes))]
}
